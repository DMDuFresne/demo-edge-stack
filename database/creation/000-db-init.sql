-- ===============================================================
-- Database: mes
-- Description: CI-Based MES Database Initialization
--
-- Author(s):
-- -- Dylan DuFresne
-- ===============================================================

-- ===============================================================
-- Set Default Schema Context
-- ===============================================================

SET search_path TO public;

-- ===============================================================
-- Ensure TimescaleDB Extension
-- ===============================================================

CREATE EXTENSION IF NOT EXISTS timescaledb;

-- ===============================================================
-- Schema: mes_audit
-- Description: Central Audit Schema
-- ===============================================================

CREATE SCHEMA IF NOT EXISTS mes_audit;
COMMENT ON SCHEMA mes_audit IS 'Central audit schema for tracking changes to MES definitional and lookup tables.';

SET search_path TO mes_audit;

-- ===============================================================
-- Table: change_log
-- ===============================================================

CREATE TABLE IF NOT EXISTS change_log (
    audit_id           BIGINT GENERATED ALWAYS AS IDENTITY,
    schema_name        TEXT NOT NULL,
    table_name         TEXT NOT NULL,
    operation          TEXT NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
    record_key         TEXT NOT NULL,
    record_value       TEXT NOT NULL,
    column_changes     JSONB,
    changed_by         TEXT DEFAULT CURRENT_USER,
    changed_at         TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    session_username   TEXT,
    application_name   TEXT,
    client_addr        INET
);

COMMENT ON TABLE change_log IS '@omit create,update,delete
Tracks all changes to MES definitional and lookup tables. Read-only via GraphQL API - audit records are automatically generated by triggers and cannot be manually created, updated, or deleted.';

-- ===============================================================
-- Function: trgfn_log_change
-- ===============================================================

CREATE OR REPLACE FUNCTION trgfn_log_change()
RETURNS TRIGGER AS
$$
DECLARE
    v_schema      TEXT := TG_TABLE_SCHEMA;
    v_table       TEXT := TG_TABLE_NAME;
    v_op          TEXT := TG_OP;
    v_user        TEXT := CURRENT_USER;
    v_session     TEXT := SESSION_USER;
    v_app         TEXT := current_setting('application_name', true);
    v_addr        INET := inet_client_addr();
    v_time        TIMESTAMPTZ := CURRENT_TIMESTAMP;
    v_pk          TEXT;
    v_pk_val      TEXT;
    v_column      TEXT;
    v_changes     JSONB := '{}'::JSONB;
BEGIN
    FOR v_column IN
        SELECT a.attname
        FROM pg_index i
        JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
        WHERE i.indrelid = TG_RELID AND i.indisprimary
    LOOP
        v_pk := v_column;
        IF v_op = 'DELETE' THEN
            v_pk_val := to_jsonb(OLD) ->> v_column;
        ELSE
            v_pk_val := to_jsonb(NEW) ->> v_column;
        END IF;
        EXIT;
    END LOOP;

    IF v_op = 'UPDATE' THEN
        FOR v_column IN
            SELECT column_name
            FROM information_schema.columns
            WHERE table_schema = v_schema
              AND table_name = v_table
              AND column_name NOT IN ('updated_at', 'updated_by', 'created_at', 'created_by')
        LOOP
            IF to_jsonb(OLD) ->> v_column IS DISTINCT FROM to_jsonb(NEW) ->> v_column THEN
                v_changes := v_changes || jsonb_build_object(
                    v_column,
                    ARRAY[
                        to_jsonb(OLD) ->> v_column,
                        to_jsonb(NEW) ->> v_column
                    ]
                );
            END IF;
        END LOOP;
    ELSIF v_op = 'INSERT' THEN
        -- For INSERT operations, log all columns as changed (from NULL to their values)
        FOR v_column IN
            SELECT column_name
            FROM information_schema.columns
            WHERE table_schema = v_schema
              AND table_name = v_table
              AND column_name NOT IN ('updated_at', 'updated_by', 'created_at', 'created_by')
        LOOP
            v_changes := v_changes || jsonb_build_object(
                v_column,
                ARRAY[
                    NULL,
                    to_jsonb(NEW) ->> v_column
                ]
            );
        END LOOP;
    ELSIF v_op = 'DELETE' THEN
        -- For DELETE operations, log all columns as changed (from their values to NULL)
        FOR v_column IN
            SELECT column_name
            FROM information_schema.columns
            WHERE table_schema = v_schema
              AND table_name = v_table
              AND column_name NOT IN ('updated_at', 'updated_by', 'created_at', 'created_by')
        LOOP
            v_changes := v_changes || jsonb_build_object(
                v_column,
                ARRAY[
                    to_jsonb(OLD) ->> v_column,
                    NULL
                ]
            );
        END LOOP;
    END IF;

    INSERT INTO mes_audit.change_log (
        schema_name,
        table_name,
        operation,
        record_key,
        record_value,
        column_changes,
        changed_by,
        changed_at,
        session_username,
        application_name,
        client_addr
    )
    VALUES (
        v_schema,
        v_table,
        v_op,
        v_pk,
        v_pk_val,
        CASE WHEN v_op IN ('UPDATE', 'INSERT', 'DELETE') THEN v_changes ELSE NULL END,
        v_user,
        v_time,
        v_session,
        v_app,
        v_addr
    );

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION trgfn_log_change IS 'Trigger function to log changes on MES definitional and lookup tables. Logs all column changes for INSERT (NULL to value), UPDATE (changed columns only), and DELETE (value to NULL) operations.';

-- ===============================================================
-- TimescaleDB Compression and Retention for mes_audit.change_log
-- ===============================================================

SET search_path TO public;

SELECT create_hypertable(
    'mes_audit.change_log',
    'changed_at',
    chunk_time_interval => INTERVAL '1 month',
    if_not_exists => TRUE
);

ALTER TABLE mes_audit.change_log
SET (
    timescaledb.compress = true,
    timescaledb.compress_segmentby = 'schema_name, table_name',
    timescaledb.compress_orderby = 'changed_at DESC'
);

SELECT add_retention_policy('mes_audit.change_log', INTERVAL '3 years');
SELECT add_compression_policy('mes_audit.change_log', INTERVAL '3 months');

-- ===============================================================
-- Schema: mes_core
-- Description: Core MES Definitional and Logging Schema
-- ===============================================================

SET search_path TO public;

CREATE SCHEMA IF NOT EXISTS mes_core;
COMMENT ON SCHEMA mes_core IS 'Core MES schema for primary definitional and logging tables.';

SET search_path TO mes_core;

-- ===============================================================
-- Role: mes_user
-- ===============================================================

DO
$$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_catalog.pg_roles WHERE rolname = 'mes_user'
    ) THEN
        CREATE ROLE mes_user LOGIN PASSWORD 'password';
    END IF;
END
$$;

-- Grant USAGE only (no CREATE - users cannot modify schema)
GRANT USAGE ON SCHEMA mes_core TO mes_user;

-- Grant full data access to existing and future tables
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA mes_core TO mes_user;
GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA mes_core TO mes_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA mes_core TO mes_user;

ALTER DEFAULT PRIVILEGES IN SCHEMA mes_core
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mes_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA mes_core
GRANT USAGE, SELECT, UPDATE ON SEQUENCES TO mes_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA mes_core
GRANT EXECUTE ON FUNCTIONS TO mes_user;

-- ===============================================================
-- Core Trigger Functions
-- ===============================================================

CREATE OR REPLACE FUNCTION trgfn_set_updated_at()
RETURNS TRIGGER AS
$$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    NEW.updated_by := CURRENT_USER;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql VOLATILE;

COMMENT ON FUNCTION trgfn_set_updated_at IS 'Trigger function to auto-update updated_at and updated_by columns.';

CREATE OR REPLACE FUNCTION fn_validate_record_exists(
    table_name TEXT,
    column_name TEXT,
    record_id BIGINT
)
RETURNS BOOLEAN AS
$$
DECLARE
    exists_flag BOOLEAN;
    sql TEXT;
BEGIN
    sql := format(
        'SELECT EXISTS (SELECT 1 FROM mes_core.%I WHERE %I = $1)',
        table_name,
        column_name
    );
    EXECUTE sql INTO exists_flag USING record_id;
    RETURN exists_flag;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION fn_validate_record_exists IS 'Validates that a given record_id exists in the specified table and column.';

CREATE OR REPLACE FUNCTION trgfn_validate_fk()
RETURNS TRIGGER AS
$$
DECLARE
    table_name TEXT := TG_ARGV[0];
    column_name TEXT := TG_ARGV[1];
    value BIGINT;
BEGIN
    EXECUTE format('SELECT ($1).%I', column_name) INTO value USING NEW;

    -- Skip validation if the value is NULL (optional foreign key)
    IF value IS NULL THEN
        RETURN NEW;
    END IF;

    IF NOT fn_validate_record_exists(table_name, column_name, value) THEN
        RAISE EXCEPTION 'Invalid reference in table %, column % = %', table_name, column_name, value;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql VOLATILE;

COMMENT ON FUNCTION trgfn_validate_fk IS 'Trigger function to dynamically validate foreign key existence.';

-- ===============================================================
-- Schema: mes_custom
-- Description: Reserved for Future Customizations
-- ===============================================================

SET search_path TO public;

CREATE SCHEMA IF NOT EXISTS mes_custom;
COMMENT ON SCHEMA mes_custom IS 'Reserved schema for project-specific MES customizations.';

SET search_path TO mes_custom;

-- Grant USAGE only (no CREATE - users cannot modify schema)
GRANT USAGE ON SCHEMA mes_custom TO mes_user;

-- Grant full data access to existing and future tables
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA mes_custom TO mes_user;
GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA mes_custom TO mes_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA mes_custom TO mes_user;

ALTER DEFAULT PRIVILEGES IN SCHEMA mes_custom
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mes_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA mes_custom
GRANT USAGE, SELECT, UPDATE ON SEQUENCES TO mes_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA mes_custom
GRANT EXECUTE ON FUNCTIONS TO mes_user;

-- ===============================================================
-- Schema Version Tracking: mes_core, mes_custom, public
-- ===============================================================

-- mes_core
SET search_path TO mes_core;

CREATE TABLE IF NOT EXISTS core_schema_version (
    version TEXT PRIMARY KEY,
    description TEXT NOT NULL,
    applied_by TEXT DEFAULT CURRENT_USER,
    applied_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE mes_core.core_schema_version IS E'@omit delete
Schema version tracking for mes_core. Use soft delete if needed (add removed column).';

INSERT INTO core_schema_version (version, description)
VALUES ('v1.0.0', 'Initialized CI-Based MES Core Schema')
ON CONFLICT (version) DO NOTHING;

-- mes_custom
SET search_path TO mes_custom;

CREATE TABLE IF NOT EXISTS custom_schema_version (
    version TEXT PRIMARY KEY,
    description TEXT NOT NULL,
    applied_by TEXT DEFAULT CURRENT_USER,
    applied_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE mes_custom.custom_schema_version IS E'@omit delete
Schema version tracking for mes_custom. Use soft delete if needed (add removed column).';

INSERT INTO custom_schema_version (version, description)
VALUES ('v1.0.0', 'Initialized Custom Schema for Project Extensions')
ON CONFLICT (version) DO NOTHING;

-- public
SET search_path TO public;

CREATE TABLE IF NOT EXISTS schema_version (
    version TEXT PRIMARY KEY,
    description TEXT NOT NULL,
    applied_by TEXT DEFAULT CURRENT_USER,
    applied_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO schema_version (version, description)
VALUES ('v1.0.0', 'Initialized Public Schema Version Tracking')
ON CONFLICT (version) DO NOTHING;

-- Reset search_path
SET search_path TO public;
